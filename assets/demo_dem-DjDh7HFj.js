const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./raw-in9isEBO.js","./basedecoder-B2c5_Eok.js","./lzw-_aCqfs4w.js","./jpeg-vtRboCKw.js","./deflate-B9JhHpvg.js","./pako.esm-Cram60i4.js","./packbits-DDWKfGV_.js","./lerc-BZfO7d0i.js","./_commonjsHelpers-CqkleIqs.js","./modulepreload-polyfill-B5Qt9EMX.js","./camera-DXA52umf.js","./webgpu-utils.module-DPkR54bZ.js","./zstd-CoMYBbf0.js","./webimage-DBgUwIbt.js"])))=>i.map(i=>d[i]);
import"./modulepreload-polyfill-B5Qt9EMX.js";import{f as me,C as Xe,a as qe,P as $e,p as He,c as Ze,b as Je,d as Qe}from"./camera-DXA52umf.js";import{m as Me,a as $}from"./webgpu-utils.module-DPkR54bZ.js";function I(r){return(e,...t)=>We(r,e,t)}function Z(r,e){return I(Ce(r,e).get)}const{apply:We,getOwnPropertyDescriptor:Ce,getPrototypeOf:Pe,ownKeys:et}=Reflect,{iterator:ae,toStringTag:tt}=Symbol,rt=Object,{create:Ge,defineProperty:it}=rt,nt=Array,ot=nt.prototype,Oe=ot[ae],st=I(Oe),_e=ArrayBuffer,at=_e.prototype;Z(at,"byteLength");const ve=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:null;ve&&Z(ve.prototype,"byteLength");const ze=Pe(Uint8Array);ze.from;const A=ze.prototype;A[ae];I(A.keys);I(A.values);I(A.entries);I(A.set);I(A.reverse);I(A.fill);I(A.copyWithin);I(A.sort);I(A.slice);I(A.subarray);Z(A,"buffer");Z(A,"byteOffset");Z(A,"length");Z(A,tt);const ct=Uint8Array,Fe=Uint16Array,De=Uint32Array,lt=Float32Array,se=Pe([][ae]()),Re=I(se.next),ft=I((function*(){})().next),ut=Pe(se),ht=DataView.prototype,gt=I(ht.getUint16),Ie=WeakMap,Le=Ie.prototype,Ne=I(Le.get),dt=I(Le.set),Ve=new Ie,pt=Ge(null,{next:{value:function(){const e=Ne(Ve,this);return Re(e)}},[ae]:{value:function(){return this}}});function yt(r){if(r[ae]===Oe&&se.next===Re)return r;const e=Ge(pt);return dt(Ve,e,st(r)),e}const mt=new Ie,xt=Ge(ut,{next:{value:function(){const e=Ne(mt,this);return ft(e)},writable:!0,configurable:!0}});for(const r of et(se))r!=="next"&&it(xt,r,Ce(se,r));const ke=new _e(4),wt=new lt(ke),Tt=new De(ke),O=new Fe(512),_=new ct(512);for(let r=0;r<256;++r){const e=r-127;e<-24?(O[r]=0,O[r|256]=32768,_[r]=24,_[r|256]=24):e<-14?(O[r]=1024>>-e-14,O[r|256]=1024>>-e-14|32768,_[r]=-e-1,_[r|256]=-e-1):e<=15?(O[r]=e+15<<10,O[r|256]=e+15<<10|32768,_[r]=13,_[r|256]=13):e<128?(O[r]=31744,O[r|256]=64512,_[r]=24,_[r|256]=24):(O[r]=31744,O[r|256]=64512,_[r]=13,_[r|256]=13)}const Ue=new De(2048);for(let r=1;r<1024;++r){let e=r<<13,t=0;for(;(e&8388608)===0;)e<<=1,t-=8388608;e&=-8388609,t+=947912704,Ue[r]=e|t}for(let r=1024;r<2048;++r)Ue[r]=939524096+(r-1024<<13);const J=new De(64);for(let r=1;r<31;++r)J[r]=r<<23;J[31]=1199570944;J[32]=2147483648;for(let r=33;r<63;++r)J[r]=2147483648+(r-32<<23);J[63]=3347054592;const Ke=new Fe(64);for(let r=1;r<64;++r)r!==32&&(Ke[r]=1024);function bt(r){const e=r>>10;return Tt[0]=Ue[Ke[e]+(r&1023)]+J[e],wt[0]}function je(r,e,...t){return bt(gt(r,e,...yt(t)))}function xe(r,e,t){const n=typeof r=="object"?r.outer:r,i=n.slice(0,n.indexOf(">")+1),o=['"',"'"];for(let a=0;a<o.length;a++){const s=o[a],l=e+"\\="+s+"([^"+s+"]*)"+s,u=new RegExp(l).exec(i);if(u)return u[1]}}function St(r,e,t){const i=new RegExp(e).exec(r.slice(t));return i?t+i.index:-1}function we(r,e,t){const i=new RegExp(e).exec(r.slice(t));return i?t+i.index+i[0].length-1:-1}function Be(r,e){const t=new RegExp(e,"g"),n=r.match(t);return n?n.length:0}function Pt(r,e,t){const n=t&&t.debug||!1,i=!(t&&typeof t.nested===!1),o=t&&t.startIndex||0;n&&console.log("[xml-utils] starting findTagByName with",e," and ",t);const a=St(r,`<${e}[ 
>/]`,o);if(n&&console.log("[xml-utils] start:",a),a===-1)return;const s=r.slice(a+e.length);let l=we(s,"^[^<]*[ /]>",0);const c=l!==-1&&s[l-1]==="/";if(n&&console.log("[xml-utils] selfClosing:",c),c===!1)if(i){let h=0,f=1,p=0;for(;(l=we(s,"[ /]"+e+">",h))!==-1;){const d=s.substring(h,l+1);if(f+=Be(d,"<"+e+`[ 
	>]`),p+=Be(d,"</"+e+">"),p>=f)break;h=l}}else l=we(s,"[ /]"+e+">",0);const u=a+e.length+l+1;if(n&&console.log("[xml-utils] end:",u),u===-1)return;const g=r.slice(a,u);let y;return c?y=null:y=g.slice(g.indexOf(">")+1,g.lastIndexOf("<")),{inner:y,outer:g,start:a,end:u}}function Gt(r,e,t){const n=[];let o=0,a;for(;a=Pt(r,e,{debug:!1,startIndex:o});)o=a.start+1+e.length,n.push(a);return n}const oe={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34412:"CZ_LSMINFO",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},z={};for(const r in oe)oe.hasOwnProperty(r)&&(z[oe[r]]=parseInt(r,10));const Dt=[z.BitsPerSample,z.ExtraSamples,z.SampleFormat,z.StripByteCounts,z.StripOffsets,z.StripRowCounts,z.TileByteCounts,z.TileOffsets,z.SubIFDs],Te={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},w={};for(const r in Te)Te.hasOwnProperty(r)&&(w[Te[r]]=parseInt(r,10));const B={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,CMYK:5,YCbCr:6,CIELab:8},It={Unspecified:0},yr={AddCompression:1},mr={None:0,Deflate:1,Zstandard:2},Ut={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"};function At(r,e){const{width:t,height:n}=r,i=new Uint8Array(t*n*3);let o;for(let a=0,s=0;a<r.length;++a,s+=3)o=256-r[a]/e*256,i[s]=o,i[s+1]=o,i[s+2]=o;return i}function vt(r,e){const{width:t,height:n}=r,i=new Uint8Array(t*n*3);let o;for(let a=0,s=0;a<r.length;++a,s+=3)o=r[a]/e*256,i[s]=o,i[s+1]=o,i[s+2]=o;return i}function Bt(r,e){const{width:t,height:n}=r,i=new Uint8Array(t*n*3),o=e.length/3,a=e.length/3*2;for(let s=0,l=0;s<r.length;++s,l+=3){const c=r[s];i[l]=e[c]/65536*256,i[l+1]=e[c+o]/65536*256,i[l+2]=e[c+a]/65536*256}return i}function Et(r){const{width:e,height:t}=r,n=new Uint8Array(e*t*3);for(let i=0,o=0;i<r.length;i+=4,o+=3){const a=r[i],s=r[i+1],l=r[i+2],c=r[i+3];n[o]=255*((255-a)/256)*((255-c)/256),n[o+1]=255*((255-s)/256)*((255-c)/256),n[o+2]=255*((255-l)/256)*((255-c)/256)}return n}function Mt(r){const{width:e,height:t}=r,n=new Uint8ClampedArray(e*t*3);for(let i=0,o=0;i<r.length;i+=3,o+=3){const a=r[i],s=r[i+1],l=r[i+2];n[o]=a+1.402*(l-128),n[o+1]=a-.34414*(s-128)-.71414*(l-128),n[o+2]=a+1.772*(s-128)}return n}const Ct=.95047,Ot=1,_t=1.08883;function zt(r){const{width:e,height:t}=r,n=new Uint8Array(e*t*3);for(let i=0,o=0;i<r.length;i+=3,o+=3){const a=r[i+0],s=r[i+1]<<24>>24,l=r[i+2]<<24>>24;let c=(a+16)/116,u=s/500+c,g=c-l/200,y,h,f;u=Ct*(u*u*u>.008856?u*u*u:(u-16/116)/7.787),c=Ot*(c*c*c>.008856?c*c*c:(c-16/116)/7.787),g=_t*(g*g*g>.008856?g*g*g:(g-16/116)/7.787),y=u*3.2406+c*-1.5372+g*-.4986,h=u*-.9689+c*1.8758+g*.0415,f=u*.0557+c*-.204+g*1.057,y=y>.0031308?1.055*y**(1/2.4)-.055:12.92*y,h=h>.0031308?1.055*h**(1/2.4)-.055:12.92*h,f=f>.0031308?1.055*f**(1/2.4)-.055:12.92*f,n[o]=Math.max(0,Math.min(1,y))*255,n[o+1]=Math.max(0,Math.min(1,h))*255,n[o+2]=Math.max(0,Math.min(1,f))*255}return n}const Ft="modulepreload",Rt=function(r,e){return new URL(r,e).href},Ee={},k=function(e,t,n){let i=Promise.resolve();if(t&&t.length>0){let c=function(u){return Promise.all(u.map(g=>Promise.resolve(g).then(y=>({status:"fulfilled",value:y}),y=>({status:"rejected",reason:y}))))};const a=document.getElementsByTagName("link"),s=document.querySelector("meta[property=csp-nonce]"),l=s?.nonce||s?.getAttribute("nonce");i=c(t.map(u=>{if(u=Rt(u,n),u in Ee)return;Ee[u]=!0;const g=u.endsWith(".css"),y=g?'[rel="stylesheet"]':"";if(n)for(let f=a.length-1;f>=0;f--){const p=a[f];if(p.href===u&&(!g||p.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${u}"]${y}`))return;const h=document.createElement("link");if(h.rel=g?"stylesheet":Ft,g||(h.as="script"),h.crossOrigin="",h.href=u,l&&h.setAttribute("nonce",l),document.head.appendChild(h),g)return new Promise((f,p)=>{h.addEventListener("load",f),h.addEventListener("error",()=>p(new Error(`Unable to preload CSS for ${u}`)))})}))}function o(a){const s=new Event("vite:preloadError",{cancelable:!0});if(s.payload=a,window.dispatchEvent(s),!s.defaultPrevented)throw a}return i.then(a=>{for(const s of a||[])s.status==="rejected"&&o(s.reason);return e().catch(o)})},Ye=new Map,Lt=new Map;function R(r,e,t=!0){Array.isArray(r)||(r=[r]),r.forEach(n=>{Ye.set(n,e),Lt.set(n,t)})}async function Nt(r){const e=Ye.get(r.Compression);if(!e)throw new Error(`Unknown compression method identifier: ${r.Compression}`);const t=await e();return new t(r)}R([void 0,1],()=>k(()=>import("./raw-in9isEBO.js"),__vite__mapDeps([0,1]),import.meta.url).then(r=>r.default),!1);R(5,()=>k(()=>import("./lzw-_aCqfs4w.js"),__vite__mapDeps([2,1]),import.meta.url).then(r=>r.default));R(6,()=>{throw new Error("old style JPEG compression is not supported.")});R(7,()=>k(()=>import("./jpeg-vtRboCKw.js"),__vite__mapDeps([3,1]),import.meta.url).then(r=>r.default));R([8,32946],()=>k(()=>import("./deflate-B9JhHpvg.js"),__vite__mapDeps([4,5,1]),import.meta.url).then(r=>r.default));R(32773,()=>k(()=>import("./packbits-DDWKfGV_.js"),__vite__mapDeps([6,1]),import.meta.url).then(r=>r.default));R(34887,()=>k(()=>import("./lerc-BZfO7d0i.js"),__vite__mapDeps([7,5,8,1,9,10,11]),import.meta.url).then(async r=>(await r.zstd.init(),r)).then(r=>r.default));R(5e4,()=>k(()=>import("./zstd-CoMYBbf0.js"),__vite__mapDeps([12,1]),import.meta.url).then(async r=>(await r.zstd.init(),r)).then(r=>r.default));R(50001,()=>k(()=>import("./webimage-DBgUwIbt.js"),__vite__mapDeps([13,1]),import.meta.url).then(r=>r.default),!1);function he(r,e,t,n=1){return new(Object.getPrototypeOf(r)).constructor(e*t*n)}function Vt(r,e,t,n,i){const o=e/n,a=t/i;return r.map(s=>{const l=he(s,n,i);for(let c=0;c<i;++c){const u=Math.min(Math.round(a*c),t-1);for(let g=0;g<n;++g){const y=Math.min(Math.round(o*g),e-1),h=s[u*e+y];l[c*n+g]=h}}return l})}function H(r,e,t){return(1-t)*r+t*e}function kt(r,e,t,n,i){const o=e/n,a=t/i;return r.map(s=>{const l=he(s,n,i);for(let c=0;c<i;++c){const u=a*c,g=Math.floor(u),y=Math.min(Math.ceil(u),t-1);for(let h=0;h<n;++h){const f=o*h,p=f%1,d=Math.floor(f),x=Math.min(Math.ceil(f),e-1),m=s[g*e+d],T=s[g*e+x],b=s[y*e+d],S=s[y*e+x],P=H(H(m,T,p),H(b,S,p),u%1);l[c*n+h]=P}}return l})}function Kt(r,e,t,n,i,o="nearest"){switch(o.toLowerCase()){case"nearest":return Vt(r,e,t,n,i);case"bilinear":case"linear":return kt(r,e,t,n,i);default:throw new Error(`Unsupported resampling method: '${o}'`)}}function jt(r,e,t,n,i,o){const a=e/n,s=t/i,l=he(r,n,i,o);for(let c=0;c<i;++c){const u=Math.min(Math.round(s*c),t-1);for(let g=0;g<n;++g){const y=Math.min(Math.round(a*g),e-1);for(let h=0;h<o;++h){const f=r[u*e*o+y*o+h];l[c*n*o+g*o+h]=f}}}return l}function Yt(r,e,t,n,i,o){const a=e/n,s=t/i,l=he(r,n,i,o);for(let c=0;c<i;++c){const u=s*c,g=Math.floor(u),y=Math.min(Math.ceil(u),t-1);for(let h=0;h<n;++h){const f=a*h,p=f%1,d=Math.floor(f),x=Math.min(Math.ceil(f),e-1);for(let m=0;m<o;++m){const T=r[g*e*o+d*o+m],b=r[g*e*o+x*o+m],S=r[y*e*o+d*o+m],P=r[y*e*o+x*o+m],v=H(H(T,b,p),H(S,P,p),u%1);l[c*n*o+h*o+m]=v}}}return l}function Xt(r,e,t,n,i,o,a="nearest"){switch(a.toLowerCase()){case"nearest":return jt(r,e,t,n,i,o);case"bilinear":case"linear":return Yt(r,e,t,n,i,o);default:throw new Error(`Unsupported resampling method: '${a}'`)}}function qt(r,e,t){let n=0;for(let i=e;i<t;++i)n+=r[i];return n}function be(r,e,t){switch(r){case 1:if(e<=8)return new Uint8Array(t);if(e<=16)return new Uint16Array(t);if(e<=32)return new Uint32Array(t);break;case 2:if(e===8)return new Int8Array(t);if(e===16)return new Int16Array(t);if(e===32)return new Int32Array(t);break;case 3:switch(e){case 16:case 32:return new Float32Array(t);case 64:return new Float64Array(t)}break}throw Error("Unsupported data format/bitsPerSample")}function $t(r,e){return(r===1||r===2)&&e<=32&&e%8===0?!1:!(r===3&&(e===16||e===32||e===64))}function Ht(r,e,t,n,i,o,a){const s=new DataView(r),l=t===2?a*o:a*o*n,c=t===2?1:n,u=be(e,i,l),g=parseInt("1".repeat(i),2);if(e===1){let y;t===1?y=n*i:y=i;let h=o*y;(h&7)!==0&&(h=h+7&-8);for(let f=0;f<a;++f){const p=f*h;for(let d=0;d<o;++d){const x=p+d*c*i;for(let m=0;m<c;++m){const T=x+m*i,b=(f*o+d)*c+m,S=Math.floor(T/8),P=T%8;if(P+i<=8)u[b]=s.getUint8(S)>>8-i-P&g;else if(P+i<=16)u[b]=s.getUint16(S)>>16-i-P&g;else if(P+i<=24){const v=s.getUint16(S)<<8|s.getUint8(S+2);u[b]=v>>24-i-P&g}else u[b]=s.getUint32(S)>>32-i-P&g}}}}return u.buffer}class Zt{constructor(e,t,n,i,o,a){this.fileDirectory=e,this.geoKeys=t,this.dataView=n,this.littleEndian=i,this.tiles=o?{}:null,this.isTiled=!e.StripOffsets;const s=e.PlanarConfiguration;if(this.planarConfiguration=typeof s>"u"?1:s,this.planarConfiguration!==1&&this.planarConfiguration!==2)throw new Error("Invalid planar configuration.");this.source=a}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return typeof this.fileDirectory.SamplesPerPixel<"u"?this.fileDirectory.SamplesPerPixel:1}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:typeof this.fileDirectory.RowsPerStrip<"u"?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBlockWidth(){return this.getTileWidth()}getBlockHeight(e){return this.isTiled||(e+1)*this.getTileHeight()<=this.getHeight()?this.getTileHeight():this.getHeight()-e*this.getTileHeight()}getBytesPerPixel(){let e=0;for(let t=0;t<this.fileDirectory.BitsPerSample.length;++t)e+=this.getSampleByteSize(t);return e}getSampleByteSize(e){if(e>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${e} is out of range.`);return Math.ceil(this.fileDirectory.BitsPerSample[e]/8)}getReaderForSample(e){const t=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1,n=this.fileDirectory.BitsPerSample[e];switch(t){case 1:if(n<=8)return DataView.prototype.getUint8;if(n<=16)return DataView.prototype.getUint16;if(n<=32)return DataView.prototype.getUint32;break;case 2:if(n<=8)return DataView.prototype.getInt8;if(n<=16)return DataView.prototype.getInt16;if(n<=32)return DataView.prototype.getInt32;break;case 3:switch(n){case 16:return function(i,o){return je(this,i,o)};case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}break}throw Error("Unsupported data format/bitsPerSample")}getSampleFormat(e=0){return this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1}getBitsPerSample(e=0){return this.fileDirectory.BitsPerSample[e]}getArrayForSample(e,t){const n=this.getSampleFormat(e),i=this.getBitsPerSample(e);return be(n,i,t)}async getTileOrStrip(e,t,n,i,o){const a=Math.ceil(this.getWidth()/this.getTileWidth()),s=Math.ceil(this.getHeight()/this.getTileHeight());let l;const{tiles:c}=this;this.planarConfiguration===1?l=t*a+e:this.planarConfiguration===2&&(l=n*a*s+t*a+e);let u,g;if(this.isTiled?(u=this.fileDirectory.TileOffsets[l],g=this.fileDirectory.TileByteCounts[l]):(u=this.fileDirectory.StripOffsets[l],g=this.fileDirectory.StripByteCounts[l]),g===0){const f=this.getBlockHeight(t)*this.getTileWidth(),p=this.planarConfiguration===2?this.getSampleByteSize(n):this.getBytesPerPixel(),d=new ArrayBuffer(f*p);return this.getArrayForSample(n,d).fill(this.getGDALNoData()||0),{x:e,y:t,sample:n,data:d}}const y=(await this.source.fetch([{offset:u,length:g}],o))[0];let h;return c===null||!c[l]?(h=(async()=>{let f=await i.decode(this.fileDirectory,y);const p=this.getSampleFormat(),d=this.getBitsPerSample();return $t(p,d)&&(f=Ht(f,p,this.planarConfiguration,this.getSamplesPerPixel(),d,this.getTileWidth(),this.getBlockHeight(t))),f})(),c!==null&&(c[l]=h)):h=c[l],{x:e,y:t,sample:n,data:await h}}async _readRaster(e,t,n,i,o,a,s,l,c){const u=this.getTileWidth(),g=this.getTileHeight(),y=this.getWidth(),h=this.getHeight(),f=Math.max(Math.floor(e[0]/u),0),p=Math.min(Math.ceil(e[2]/u),Math.ceil(y/u)),d=Math.max(Math.floor(e[1]/g),0),x=Math.min(Math.ceil(e[3]/g),Math.ceil(h/g)),m=e[2]-e[0];let T=this.getBytesPerPixel();const b=[],S=[];for(let G=0;G<t.length;++G)this.planarConfiguration===1?b.push(qt(this.fileDirectory.BitsPerSample,0,t[G])/8):b.push(0),S.push(this.getReaderForSample(t[G]));const P=[],{littleEndian:v}=this;for(let G=d;G<x;++G)for(let Y=f;Y<p;++Y){let Q;this.planarConfiguration===1&&(Q=this.getTileOrStrip(Y,G,0,o,c));for(let D=0;D<t.length;++D){const W=D,L=t[D];this.planarConfiguration===2&&(T=this.getSampleByteSize(L),Q=this.getTileOrStrip(Y,G,L,o,c));const ee=Q.then(E=>{const ce=E.data,te=new DataView(ce),X=this.getBlockHeight(E.y),N=E.y*g,K=E.x*u,le=N+X,re=(E.x+1)*u,ie=S[W],ge=Math.min(X,X-(le-e[3]),h-N),de=Math.min(u,u-(re-e[2]),y-K);for(let V=Math.max(0,e[1]-N);V<ge;++V)for(let M=Math.max(0,e[0]-K);M<de;++M){const fe=(V*u+M)*T,pe=ie.call(te,fe+b[W],v);let j;i?(j=(V+N-e[1])*m*t.length+(M+K-e[0])*t.length+W,n[j]=pe):(j=(V+N-e[1])*m+M+K-e[0],n[W][j]=pe)}});P.push(ee)}}if(await Promise.all(P),a&&e[2]-e[0]!==a||s&&e[3]-e[1]!==s){let G;return i?G=Xt(n,e[2]-e[0],e[3]-e[1],a,s,t.length,l):G=Kt(n,e[2]-e[0],e[3]-e[1],a,s,l),G.width=a,G.height=s,G}return n.width=a||e[2]-e[0],n.height=s||e[3]-e[1],n}async readRasters({window:e,samples:t=[],interleave:n,pool:i=null,width:o,height:a,resampleMethod:s,fillValue:l,signal:c}={}){const u=e||[0,0,this.getWidth(),this.getHeight()];if(u[0]>u[2]||u[1]>u[3])throw new Error("Invalid subsets");const g=u[2]-u[0],y=u[3]-u[1],h=g*y,f=this.getSamplesPerPixel();if(!t||!t.length)for(let m=0;m<f;++m)t.push(m);else for(let m=0;m<t.length;++m)if(t[m]>=f)return Promise.reject(new RangeError(`Invalid sample index '${t[m]}'.`));let p;if(n){const m=this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,T=Math.max.apply(null,this.fileDirectory.BitsPerSample);p=be(m,T,h*t.length),l&&p.fill(l)}else{p=[];for(let m=0;m<t.length;++m){const T=this.getArrayForSample(t[m],h);Array.isArray(l)&&m<l.length?T.fill(l[m]):l&&!Array.isArray(l)&&T.fill(l),p.push(T)}}const d=i||await Nt(this.fileDirectory);return await this._readRaster(u,t,p,n,d,o,a,s,c)}async readRGB({window:e,interleave:t=!0,pool:n=null,width:i,height:o,resampleMethod:a,enableAlpha:s=!1,signal:l}={}){const c=e||[0,0,this.getWidth(),this.getHeight()];if(c[0]>c[2]||c[1]>c[3])throw new Error("Invalid subsets");const u=this.fileDirectory.PhotometricInterpretation;if(u===B.RGB){let x=[0,1,2];if(this.fileDirectory.ExtraSamples!==It.Unspecified&&s){x=[];for(let m=0;m<this.fileDirectory.BitsPerSample.length;m+=1)x.push(m)}return this.readRasters({window:e,interleave:t,samples:x,pool:n,width:i,height:o,resampleMethod:a,signal:l})}let g;switch(u){case B.WhiteIsZero:case B.BlackIsZero:case B.Palette:g=[0];break;case B.CMYK:g=[0,1,2,3];break;case B.YCbCr:case B.CIELab:g=[0,1,2];break;default:throw new Error("Invalid or unsupported photometric interpretation.")}const y={window:c,interleave:!0,samples:g,pool:n,width:i,height:o,resampleMethod:a,signal:l},{fileDirectory:h}=this,f=await this.readRasters(y),p=2**this.fileDirectory.BitsPerSample[0];let d;switch(u){case B.WhiteIsZero:d=At(f,p);break;case B.BlackIsZero:d=vt(f,p);break;case B.Palette:d=Bt(f,h.ColorMap);break;case B.CMYK:d=Et(f);break;case B.YCbCr:d=Mt(f);break;case B.CIELab:d=zt(f);break;default:throw new Error("Unsupported photometric interpretation.")}if(!t){const x=new Uint8Array(d.length/3),m=new Uint8Array(d.length/3),T=new Uint8Array(d.length/3);for(let b=0,S=0;b<d.length;b+=3,++S)x[S]=d[b],m[S]=d[b+1],T[S]=d[b+2];d=[x,m,T]}return d.width=f.width,d.height=f.height,d}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const e=[];for(let t=0;t<this.fileDirectory.ModelTiepoint.length;t+=6)e.push({i:this.fileDirectory.ModelTiepoint[t],j:this.fileDirectory.ModelTiepoint[t+1],k:this.fileDirectory.ModelTiepoint[t+2],x:this.fileDirectory.ModelTiepoint[t+3],y:this.fileDirectory.ModelTiepoint[t+4],z:this.fileDirectory.ModelTiepoint[t+5]});return e}getGDALMetadata(e=null){const t={};if(!this.fileDirectory.GDAL_METADATA)return null;const n=this.fileDirectory.GDAL_METADATA;let i=Gt(n,"Item");e===null?i=i.filter(o=>xe(o,"sample")===void 0):i=i.filter(o=>Number(xe(o,"sample"))===e);for(let o=0;o<i.length;++o){const a=i[o];t[xe(a,"name")]=a.inner}return t}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const e=this.fileDirectory.GDAL_NODATA;return Number(e.substring(0,e.length-1))}getOrigin(){const e=this.fileDirectory.ModelTiepoint,t=this.fileDirectory.ModelTransformation;if(e&&e.length===6)return[e[3],e[4],e[5]];if(t)return[t[3],t[7],t[11]];throw new Error("The image does not have an affine transformation.")}getResolution(e=null){const t=this.fileDirectory.ModelPixelScale,n=this.fileDirectory.ModelTransformation;if(t)return[t[0],-t[1],t[2]];if(n)return n[1]===0&&n[4]===0?[n[0],-n[5],n[10]]:[Math.sqrt(n[0]*n[0]+n[4]*n[4]),-Math.sqrt(n[1]*n[1]+n[5]*n[5]),n[10]];if(e){const[i,o,a]=e.getResolution();return[i*e.getWidth()/this.getWidth(),o*e.getHeight()/this.getHeight(),a*e.getWidth()/this.getWidth()]}throw new Error("The image does not have an affine transformation.")}pixelIsArea(){return this.geoKeys.GTRasterTypeGeoKey===1}getBoundingBox(e=!1){const t=this.getHeight(),n=this.getWidth();if(this.fileDirectory.ModelTransformation&&!e){const[i,o,a,s,l,c,u,g]=this.fileDirectory.ModelTransformation,h=[[0,0],[0,t],[n,0],[n,t]].map(([d,x])=>[s+i*d+o*x,g+l*d+c*x]),f=h.map(d=>d[0]),p=h.map(d=>d[1]);return[Math.min(...f),Math.min(...p),Math.max(...f),Math.max(...p)]}else{const i=this.getOrigin(),o=this.getResolution(),a=i[0],s=i[1],l=a+o[0]*n,c=s+o[1]*t;return[Math.min(a,l),Math.min(s,c),Math.max(a,l),Math.max(s,c)]}}}class Jt{constructor(e){this._dataView=new DataView(e)}get buffer(){return this._dataView.buffer}getUint64(e,t){const n=this.getUint32(e,t),i=this.getUint32(e+4,t);let o;if(t){if(o=n+2**32*i,!Number.isSafeInteger(o))throw new Error(`${o} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return o}if(o=2**32*n+i,!Number.isSafeInteger(o))throw new Error(`${o} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return o}getInt64(e,t){let n=0;const i=(this._dataView.getUint8(e+(t?7:0))&128)>0;let o=!0;for(let a=0;a<8;a++){let s=this._dataView.getUint8(e+(t?a:7-a));i&&(o?s!==0&&(s=~(s-1)&255,o=!1):s=~s&255),n+=s*256**a}return i&&(n=-n),n}getUint8(e,t){return this._dataView.getUint8(e,t)}getInt8(e,t){return this._dataView.getInt8(e,t)}getUint16(e,t){return this._dataView.getUint16(e,t)}getInt16(e,t){return this._dataView.getInt16(e,t)}getUint32(e,t){return this._dataView.getUint32(e,t)}getInt32(e,t){return this._dataView.getInt32(e,t)}getFloat16(e,t){return je(this._dataView,e,t)}getFloat32(e,t){return this._dataView.getFloat32(e,t)}getFloat64(e,t){return this._dataView.getFloat64(e,t)}}class Qt{constructor(e,t,n,i){this._dataView=new DataView(e),this._sliceOffset=t,this._littleEndian=n,this._bigTiff=i}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(e,t){return this.sliceOffset<=e&&this.sliceTop>=e+t}readUint8(e){return this._dataView.getUint8(e-this._sliceOffset,this._littleEndian)}readInt8(e){return this._dataView.getInt8(e-this._sliceOffset,this._littleEndian)}readUint16(e){return this._dataView.getUint16(e-this._sliceOffset,this._littleEndian)}readInt16(e){return this._dataView.getInt16(e-this._sliceOffset,this._littleEndian)}readUint32(e){return this._dataView.getUint32(e-this._sliceOffset,this._littleEndian)}readInt32(e){return this._dataView.getInt32(e-this._sliceOffset,this._littleEndian)}readFloat32(e){return this._dataView.getFloat32(e-this._sliceOffset,this._littleEndian)}readFloat64(e){return this._dataView.getFloat64(e-this._sliceOffset,this._littleEndian)}readUint64(e){const t=this.readUint32(e),n=this.readUint32(e+4);let i;if(this._littleEndian){if(i=t+2**32*n,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}if(i=2**32*t+n,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}readInt64(e){let t=0;const n=(this._dataView.getUint8(e+(this._littleEndian?7:0))&128)>0;let i=!0;for(let o=0;o<8;o++){let a=this._dataView.getUint8(e+(this._littleEndian?o:7-o));n&&(i?a!==0&&(a=~(a-1)&255,i=!1):a=~a&255),t+=a*256**o}return n&&(t=-t),t}readOffset(e){return this._bigTiff?this.readUint64(e):this.readUint32(e)}}class Wt{async fetch(e,t=void 0){return Promise.all(e.map(n=>this.fetchSlice(n,t)))}async fetchSlice(e){throw new Error(`fetching of slice ${e} not possible, not implemented`)}get fileSize(){return null}async close(){}}class er extends Wt{constructor(e){super(),this.file=e}async fetchSlice(e,t){return new Promise((n,i)=>{const o=this.file.slice(e.offset,e.offset+e.length),a=new FileReader;a.onload=s=>n(s.target.result),a.onerror=i,a.onabort=i,a.readAsArrayBuffer(o),t&&t.addEventListener("abort",()=>a.abort())})}}function tr(r){return new er(r)}function Se(r){switch(r){case w.BYTE:case w.ASCII:case w.SBYTE:case w.UNDEFINED:return 1;case w.SHORT:case w.SSHORT:return 2;case w.LONG:case w.SLONG:case w.FLOAT:case w.IFD:return 4;case w.RATIONAL:case w.SRATIONAL:case w.DOUBLE:case w.LONG8:case w.SLONG8:case w.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${r}`)}}function rr(r){const e=r.GeoKeyDirectory;if(!e)return null;const t={};for(let n=4;n<=e[3]*4;n+=4){const i=Ut[e[n]],o=e[n+1]?oe[e[n+1]]:null,a=e[n+2],s=e[n+3];let l=null;if(!o)l=s;else{if(l=r[o],typeof l>"u"||l===null)throw new Error(`Could not get value of geoKey '${i}'.`);typeof l=="string"?l=l.substring(s,s+a-1):l.subarray&&(l=l.subarray(s,s+a),a===1&&(l=l[0]))}t[i]=l}return t}function q(r,e,t,n){let i=null,o=null;const a=Se(e);switch(e){case w.BYTE:case w.ASCII:case w.UNDEFINED:i=new Uint8Array(t),o=r.readUint8;break;case w.SBYTE:i=new Int8Array(t),o=r.readInt8;break;case w.SHORT:i=new Uint16Array(t),o=r.readUint16;break;case w.SSHORT:i=new Int16Array(t),o=r.readInt16;break;case w.LONG:case w.IFD:i=new Uint32Array(t),o=r.readUint32;break;case w.SLONG:i=new Int32Array(t),o=r.readInt32;break;case w.LONG8:case w.IFD8:i=new Array(t),o=r.readUint64;break;case w.SLONG8:i=new Array(t),o=r.readInt64;break;case w.RATIONAL:i=new Uint32Array(t*2),o=r.readUint32;break;case w.SRATIONAL:i=new Int32Array(t*2),o=r.readInt32;break;case w.FLOAT:i=new Float32Array(t),o=r.readFloat32;break;case w.DOUBLE:i=new Float64Array(t),o=r.readFloat64;break;default:throw new RangeError(`Invalid field type: ${e}`)}if(e===w.RATIONAL||e===w.SRATIONAL)for(let s=0;s<t;s+=2)i[s]=o.call(r,n+s*a),i[s+1]=o.call(r,n+(s*a+4));else for(let s=0;s<t;++s)i[s]=o.call(r,n+s*a);return e===w.ASCII?new TextDecoder("utf-8").decode(i):i}class ir{constructor(e,t,n,i){this.fileDirectory=e,this.rawFileDirectory=t,this.geoKeyDirectory=n,this.nextIFDByteOffset=i}}class ue extends Error{constructor(e){super(`No image at index ${e}`),this.index=e}}class nr{async readRasters(e={}){const{window:t,width:n,height:i}=e;let{resX:o,resY:a,bbox:s}=e;const l=await this.getImage();let c=l;const u=await this.getImageCount(),g=l.getBoundingBox();if(t&&s)throw new Error('Both "bbox" and "window" passed.');if(n||i){if(t){const[f,p]=l.getOrigin(),[d,x]=l.getResolution();s=[f+t[0]*d,p+t[1]*x,f+t[2]*d,p+t[3]*x]}const h=s||g;if(n){if(o)throw new Error("Both width and resX passed");o=(h[2]-h[0])/n}if(i){if(a)throw new Error("Both width and resY passed");a=(h[3]-h[1])/i}}if(o||a){const h=[];for(let f=0;f<u;++f){const p=await this.getImage(f),{SubfileType:d,NewSubfileType:x}=p.fileDirectory;(f===0||d===2||x&1)&&h.push(p)}h.sort((f,p)=>f.getWidth()-p.getWidth());for(let f=0;f<h.length;++f){const p=h[f],d=(g[2]-g[0])/p.getWidth(),x=(g[3]-g[1])/p.getHeight();if(c=p,o&&o>d||a&&a>x)break}}let y=t;if(s){const[h,f]=l.getOrigin(),[p,d]=c.getResolution(l);y=[Math.round((s[0]-h)/p),Math.round((s[1]-f)/d),Math.round((s[2]-h)/p),Math.round((s[3]-f)/d)],y=[Math.min(y[0],y[2]),Math.min(y[1],y[3]),Math.max(y[0],y[2]),Math.max(y[1],y[3])]}return c.readRasters({...e,window:y})}}class Ae extends nr{constructor(e,t,n,i,o={}){super(),this.source=e,this.littleEndian=t,this.bigTiff=n,this.firstIFDOffset=i,this.cache=o.cache||!1,this.ifdRequests=[],this.ghostValues=null}async getSlice(e,t){const n=this.bigTiff?4048:1024;return new Qt((await this.source.fetch([{offset:e,length:typeof t<"u"?t:n}]))[0],e,this.littleEndian,this.bigTiff)}async parseFileDirectoryAt(e){const t=this.bigTiff?20:12,n=this.bigTiff?8:2;let i=await this.getSlice(e);const o=this.bigTiff?i.readUint64(e):i.readUint16(e),a=o*t+(this.bigTiff?16:6);i.covers(e,a)||(i=await this.getSlice(e,a));const s={},l=new Map;let c=e+(this.bigTiff?8:2);for(let y=0;y<o;c+=t,++y){const h=i.readUint16(c),f=i.readUint16(c+2),p=this.bigTiff?i.readUint64(c+4):i.readUint32(c+4);let d,x;const m=Se(f),T=c+(this.bigTiff?12:8);if(m*p<=(this.bigTiff?8:4))d=q(i,f,p,T);else{const S=i.readOffset(T),P=Se(f)*p;if(i.covers(S,P))d=q(i,f,p,S);else{const v=await this.getSlice(S,P);d=q(v,f,p,S)}}p===1&&Dt.indexOf(h)===-1&&!(f===w.RATIONAL||f===w.SRATIONAL)?x=d[0]:x=d;const b=oe[h];b&&(s[b]=x),l.set(h,x)}const u=rr(s),g=i.readOffset(e+n+t*o);return new ir(s,l,u,g)}async requestIFD(e){if(this.ifdRequests[e])return this.ifdRequests[e];if(e===0)return this.ifdRequests[e]=this.parseFileDirectoryAt(this.firstIFDOffset),this.ifdRequests[e];if(!this.ifdRequests[e-1])try{this.ifdRequests[e-1]=this.requestIFD(e-1)}catch(t){throw t instanceof ue?new ue(e):t}return this.ifdRequests[e]=(async()=>{const t=await this.ifdRequests[e-1];if(t.nextIFDByteOffset===0)throw new ue(e);return this.parseFileDirectoryAt(t.nextIFDByteOffset)})(),this.ifdRequests[e]}async getImage(e=0){const t=await this.requestIFD(e);return new Zt(t.fileDirectory,t.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){let e=0,t=!0;for(;t;)try{await this.requestIFD(e),++e}catch(n){if(n instanceof ue)t=!1;else throw n}return e}async getGhostValues(){const e=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const t="GDAL_STRUCTURAL_METADATA_SIZE=",n=t.length+100;let i=await this.getSlice(e,n);if(t===q(i,w.ASCII,t.length,e)){const a=q(i,w.ASCII,n,e).split(`
`)[0],s=Number(a.split("=")[1].split(" ")[0])+a.length;s>n&&(i=await this.getSlice(e,s));const l=q(i,w.ASCII,s,e);this.ghostValues={},l.split(`
`).filter(c=>c.length>0).map(c=>c.split("=")).forEach(([c,u])=>{this.ghostValues[c]=u})}return this.ghostValues}static async fromSource(e,t,n){const i=(await e.fetch([{offset:0,length:1024}],n))[0],o=new Jt(i),a=o.getUint16(0,0);let s;if(a===18761)s=!0;else if(a===19789)s=!1;else throw new TypeError("Invalid byte order value.");const l=o.getUint16(2,s);let c;if(l===42)c=!1;else if(l===43){if(c=!0,o.getUint16(4,s)!==8)throw new Error("Unsupported offset byte-size.")}else throw new TypeError("Invalid magic number.");const u=c?o.getUint64(8,s):o.getUint32(4,s);return new Ae(e,s,c,u,t)}close(){return typeof this.source.close=="function"?this.source.close():!1}}async function or(r,e){return Ae.fromSource(tr(r),e)}async function sr(r,e){const t=e.getWidth(),n=e.getHeight(),o=(await e.readRasters())[0],a=r.createTexture({label:"geotiff texture",size:[t,n,1],format:"r32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST});return r.queue.writeTexture({texture:a},o.buffer,{bytesPerRow:t*4},[t,n]),a}async function ar(r,e={level:4}){const t=r.getBoundingBox(),n=r.getWidth(),i=r.getHeight(),o=r.geoKeys;o.ProjectedCSTypeGeoKey||o.GeographicTypeGeoKey;const a=[],s=[],c=(await r.readRasters())[0];function u(h,f){return[(h-t[0])/(t[2]-t[0]),(f-t[1])/(t[3]-t[1])]}function g(h,f){const[p,d,x,m]=t;let T=Math.floor((h-p)/(x-p)*n),b=Math.floor((m-f)/(m-d)*i);T=Math.max(0,Math.min(n-1,T)),b=Math.max(0,Math.min(i-1,b));const S=b*n+T;return c[S]}function y([h,f,p,d],x=0){if(x<e.level){const m=(h+p)/2,T=(f+d)/2,b=[h,f,m,T],S=[m,f,p,T],P=[h,T,m,d],v=[m,T,p,d];y(b,x+1),y(S,x+1),y(P,x+1),y(v,x+1)}else a.push(h,f,g(h,f),p,d,g(p,d),h,d,g(h,d),h,f,g(h,f),p,f,g(p,f),p,d,g(p,d)),s.push(...u(h,f),...u(p,d),...u(h,d),...u(h,f),...u(p,f),...u(p,d))}return y(t,0),{positions:new Float32Array(a),texcoords:new Float32Array(s),vertexCount:a.length/3}}async function cr(r,e,t){const n="visualizeDEM",{device:i}=r,o=new lr(r),a=await ar(t,{level:4}),s={exaggeration:2,derivative:"none"},l=i.createTexture({size:[1,1,1],format:"r32float",usage:GPUTextureUsage.TEXTURE_BINDING});let c=null,u=null,g=[0,Math.PI/2],y=1/0,h=-1/0;for(let C=2;C<a.positions.length;C+=3){const U=a.positions[C];U<y&&(y=U),U>h&&(h=U)}const f=`

        struct Camemra {
            eye: vec3f,
            to: vec3f,
            up: vec3f,
            viewmtx : mat4x4<f32>,
            relViewmtx : mat4x4<f32>
        };

        struct Projection {
            projmtx : mat4x4<f32>
        };

        struct Scene {
            camera : Camemra,
            projection: Projection,
        };

        @group(0) @binding(0) var<uniform> scene : Scene;
        @group(0) @binding(1) var<uniform> hrange : vec2f;
        @group(0) @binding(2) var<uniform> exaggeration : f32;
        @group(1) @binding(0) var<uniform> hasTexture : u32;
        @group(1) @binding(1) var demTexture: texture_2d<f32>;
        @group(1) @binding(2) var<uniform> pixelRange: vec2f;

        struct VSInput {
            @location(0) position : vec4f,
            @location(1) texcoord : vec2f
        };
        struct VSOutput {
            @builtin(position) position : vec4f,
            @location(0) height: f32,
            @location(1) texcoord : vec2f
        };

        @vertex fn vs(input: VSInput) -> VSOutput {
            var output : VSOutput;
            var worldpos = input.position.xyz;
            worldpos.z = (worldpos.z - hrange.x) * exaggeration + hrange.x;
            let relpos = vec4f((worldpos - scene.camera.eye.xyz), 1.0);
            output.position = scene.projection.projmtx * scene.camera.relViewmtx * relpos;
            output.height = worldpos.z;
            output.texcoord = input.texcoord;
            return output;
        }

        fn demColor(h: f32) -> vec3<f32> {
            let c0 = vec3(0.0, 0.0, 0.5); // low
            let c1 = vec3(0.0, 0.6, 0.6);
            let c2 = vec3(0.2, 0.7, 0.2);
            let c3 = vec3(0.8, 0.8, 0.2);
            let c4 = vec3(0.8, 0.4, 0.1);
            let c5 = vec3(1.0, 1.0, 1.0); // high

            let t = clamp(h, 0.0, 1.0) * 5.0;

            var col = mix(c0, c1, clamp(t, 0.0, 1.0));
            col = mix(col, c2, clamp(t - 1.0, 0.0, 1.0));
            col = mix(col, c3, clamp(t - 2.0, 0.0, 1.0));
            col = mix(col, c4, clamp(t - 3.0, 0.0, 1.0));
            col = mix(col, c5, clamp(t - 4.0, 0.0, 1.0));

            return col;
        }

        @fragment fn fs(input: VSOutput) -> @location(0) vec4f {
            if(hasTexture != 0u) {
                let vmin = pixelRange[0];
                let vmax = pixelRange[1];
                let texcoord = input.texcoord;
                let size = textureDimensions(demTexture);
                let x = u32(f32(size.x) * texcoord.x);
                let y = u32(f32(size.y) * (1-texcoord.y));
                let v = textureLoad(demTexture, vec2<u32>(x,y), 0).r;
                let nv = (v-vmin)/vmax;
                let color = vec4f(demColor(nv), 1.0);
                return color;
            } else {
                let hmin = hrange.x;
                let hmax = (hrange.y-hrange.x) * exaggeration + hrange.x;
                let r = (input.height - hmin) / hmax;
                let color = vec4f(demColor(r),1.0);
                return color;
            }
        }
    `,p=i.createShaderModule({label:n,code:f}),d=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),x=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float",viewDimension:"2d",multisampled:!1}},{binding:2,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),m=i.createPipelineLayout({bindGroupLayouts:[d,x]}),T=i.createRenderPipeline({label:n,layout:m,vertex:{module:p,buffers:[{arrayStride:12,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]},{arrayStride:8,attributes:[{shaderLocation:1,offset:0,format:"float32x2"}]}]},fragment:{module:p,targets:[{format:e.context.getConfiguration().format}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth32float"}}),b=i.createBuffer({label:`${n} positionBuffer`,size:a.positions.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});i.queue.writeBuffer(b,0,a.positions.buffer);const S=i.createBuffer({label:`${n} texcoordBuffer`,size:a.texcoords.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});i.queue.writeBuffer(S,0,a.texcoords.buffer);const P=t.getBoundingBox(),v=[(P[0]+P[2])/2,(P[1]+P[3])/2],G=me(v[0],v[1],0,1),Y=me(v[0]+200,v[1]+800,1e3,1),Q=me(0,0,1,1),D=new Xe(Y,G,Q);new qe(D,e.canvas).enable();const L=Me(f),ee=$(L.uniforms.scene),E=$(L.uniforms.hrange),ce=$(L.uniforms.exaggeration),te=$(L.uniforms.hasTexture),X=$(L.uniforms.pixelRange),N=i.createBuffer({label:`${n} sceneUniform`,size:ee.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),K=i.createBuffer({label:`${n} hrangeUniform`,size:E.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});E.set([y,h]),i.queue.writeBuffer(K,0,E.arrayBuffer);const le=i.createBuffer({label:`${n} exaggerationUniform`,size:E.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),re=i.createBuffer({label:`${n} hasTextureUniform`,size:te.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),ie=i.createBuffer({label:`${n} pixelRangeUniform`,size:E.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),ge=i.createBindGroup({label:n,layout:T.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:N}},{binding:1,resource:{buffer:K}},{binding:2,resource:{buffer:le}}]}),de=l;let V=i.createBindGroup({label:n,layout:T.getBindGroupLayout(1),entries:[{binding:0,resource:re},{binding:1,resource:de},{binding:2,resource:{buffer:ie}}]}),M=i.createTexture({size:[e.canvas.width,e.canvas.height],format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT});function fe(){const C=D.viewMtx,U=He(Ze(),Math.PI/2,e.canvas.width/e.canvas.height,.1,1e4);ee.set({camera:{eye:[D.from[0],D.from[1],D.from[2]],to:[D.to[0],D.to[1],D.to[2]],up:[D.up[0],D.up[1],D.up[2]],viewmtx:C,relViewmtx:D.getRelViewMatrix()},projection:{projmtx:U}}),i.queue.writeBuffer(N,0,ee.arrayBuffer),ce.set(s.exaggeration),i.queue.writeBuffer(le,0,ce.arrayBuffer),te.set(s.derivative==="none"?0:1),i.queue.writeBuffer(re,0,te.arrayBuffer),X.set(g),i.queue.writeBuffer(ie,0,X.arrayBuffer),(M.height!==e.canvas.height||M.width!==e.canvas.width)&&(M.destroy(),M=i.createTexture({size:[e.canvas.width,e.canvas.height],format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT}));const ne=i.createCommandEncoder({label:n}),F=ne.beginRenderPass({label:n,colorAttachments:[{clearValue:[.3,.3,.3,1],loadOp:"clear",storeOp:"store",view:e.context.getCurrentTexture().createView()}],depthStencilAttachment:{view:M.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});F.setPipeline(T),F.setBindGroup(0,ge),F.setBindGroup(1,V),F.setVertexBuffer(0,b),F.setVertexBuffer(1,S),F.draw(a.vertexCount),F.end();const ye=ne.finish({label:n});i.queue.submit([ye]),requestAnimationFrame(fe)}new ResizeObserver(C=>{for(const U of C){const ne=U.target,F=U.contentBoxSize[0].inlineSize,ye=U.contentBoxSize[0].blockSize;ne.width=Math.max(1,Math.min(F,i.limits.maxTextureDimension2D)),ne.height=Math.max(1,Math.min(ye,i.limits.maxTextureDimension2D))}}).observe(e.canvas);const j=new $e({title:"参数控制",expanded:!0});j.addBinding(s,"exaggeration",{min:0,max:10,step:.1,label:"exaggeration"}),j.addBinding(s,"derivative",{options:{无:"none",坡度:"slope",坡向:"aspect"}}).on("change",async C=>{let U=null;C.value==="slope"?(c===null&&(c=await o.computeSlope(t)),U=c,g=[0,Math.PI/2]):C.value==="aspect"?(u===null&&(u=await o.computeAspect(t)),U=u,g=[0,360]):U=l,V=i.createBindGroup({label:n,layout:T.getBindGroupLayout(1),entries:[{binding:0,resource:re},{binding:1,resource:U},{binding:2,resource:{buffer:ie}}]})}),requestAnimationFrame(fe)}class lr{gpuinfo;workGroupSizeX=8;workGroupSizeY=8;workGroupSizeZ=1;slopeComputeInfo;slopeTexture=null;aspectComputeInfo;aspectTexture=null;slopeKernel=`
    
        fn kernel(
            z1:f32,z2:f32,z3:f32,
            z4:f32,z5:f32,z6:f32,
            z7:f32,z8:f32,z9:f32
        ) -> f32 {
            let dx = ((z3 + 2 * z6 + z9) - (z1 + 2 * z4 + z7)) * demInfo.zfactor / (8 * demInfo.resolution.x);
            let dy = ((z7 + 2*z8 + z9) - (z1 + 2*z2 + z3)) * demInfo.zfactor  / (8 * demInfo.resolution.y);
            let s = atan(sqrt(pow(dx,2)+pow(dy,2)));
            return s;
        }

    `;aspectKernel=`
    
        fn kernel(
            z1:f32,z2:f32,z3:f32,
            z4:f32,z5:f32,z6:f32,
            z7:f32,z8:f32,z9:f32
        ) -> f32 {
            
            let fx = ((z3+2*z6+z9)-(z1+2*z4+z7)) / (8 * demInfo.resolution.x);
            let fy = ((z1+2*z2+z3)-(z7+2*z8+z9)) / (8 * demInfo.resolution.y);
            if(fx==0.0 && fy==0.0) {
                return 0.0;
            }
            let aspect_rad = atan2(fy, -fx);
            let aspect_deg = degrees(aspect_rad);
            var aspect = 90 - aspect_deg;
            if(aspect < 0.0) {
                aspect += 360;
            }
            return aspect;
        }

    `;constructor(e){this.gpuinfo=e;const t=e.device.limits;this.workGroupSizeX=Math.min(Math.sqrt(t.maxComputeInvocationsPerWorkgroup),t.maxComputeWorkgroupSizeX),this.workGroupSizeY=Math.min(Math.sqrt(t.maxComputeInvocationsPerWorkgroup),t.maxComputeWorkgroupSizeY),this.workGroupSizeZ=1,this.slopeComputeInfo=this.createCovolution3x3Pipeline(e,"slope compute",this.slopeKernel),this.aspectComputeInfo=this.createCovolution3x3Pipeline(e,"aspect compute",this.aspectKernel)}async computeSlope(e){if(this.slopeTexture===null){const t=await this.convolute3x3(this.gpuinfo,this.slopeComputeInfo,e);this.slopeTexture=t}return this.slopeTexture}async computeAspect(e){if(this.aspectTexture===null){const t=await this.convolute3x3(this.gpuinfo,this.aspectComputeInfo,e);this.aspectTexture=t}return this.aspectTexture}createCovolution3x3Pipeline(e,t,n){const{device:i}=e,o=`

            override workGroupSizeX : u32 = 8u;
            override workGroupSizeY : u32 = 8u;
            override workGroupSizeZ : u32 = 1u;
            struct DEMInfo {
                resolution : vec2f,
                zfactor : f32
            }
            @group(0) @binding(0) var dem : texture_2d<f32>;
            @group(0) @binding(1) var outTexture : texture_storage_2d<r32float, read_write>;
            @group(0) @binding(2) var<uniform> demInfo : DEMInfo;
            ${n}
            @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ) fn cs(
                @builtin(workgroup_id) wid : vec3<u32>,
                @builtin(global_invocation_id) gid : vec3<u32>,
                @builtin(local_invocation_id) lid : vec3<u32>
            ) {
                let size = textureDimensions(dem);
                let w = size.x;
                let h = size.y;
                let x = gid.x;
                let y = gid.y;
                let coords = vec2<u32>(x,y);
                let cmin = vec2<u32>(0,0);
                let cmax = vec2<u32>(w-1,h-1);
                let c1 = clamp(vec2<u32>(x-1,y-1),cmin,cmax);
                let c2 = clamp(vec2<u32>(x-1,y),cmin,cmax);
                let c3 = clamp(vec2<u32>(x-1,y+1),cmin,cmax);
                let c4 = clamp(vec2<u32>(x,y-1),cmin,cmax);
                let c5 = clamp(vec2<u32>(x,y),cmin,cmax);
                let c6 = clamp(vec2<u32>(x,y+1),cmin,cmax);
                let c7 = clamp(vec2<u32>(x+1,y-1),cmin,cmax);
                let c8 = clamp(vec2<u32>(x+1,y),cmin,cmax);
                let c9 = clamp(vec2<u32>(x+1,y+1),cmin,cmax);
                let z1 = textureLoad(dem, c1, 0).r;
                let z2 = textureLoad(dem, c2, 0).r;
                let z3 = textureLoad(dem, c3, 0).r;
                let z4 = textureLoad(dem, c4, 0).r;
                let z5 = textureLoad(dem, c5, 0).r;
                let z6 = textureLoad(dem, c6, 0).r;
                let z7 = textureLoad(dem, c7, 0).r;
                let z8 = textureLoad(dem, c8, 0).r;
                let z9 = textureLoad(dem, c9, 0).r;
                let s = kernel(z1,z2,z3,z4,z5,z6,z7,z8,z9);
                textureStore(outTexture, coords, vec4f(s,0,0,0));
            }
    
        `,a=i.createShaderModule({label:t,code:o});return{pipeline:i.createComputePipeline({label:t,layout:"auto",compute:{module:a,constants:{workGroupSizeX:this.workGroupSizeX,workGroupSizeY:this.workGroupSizeY,workGroupSizeZ:this.workGroupSizeZ}}}),definations:Me(o)}}async convolute3x3(e,t,n){const{device:i}=e,{pipeline:o,definations:a}=t,s="convolute3x3",l=await sr(i,n),c=n.getWidth(),u=n.getHeight(),g=Math.ceil(c/this.workGroupSizeX),y=Math.ceil(u/this.workGroupSizeY),h=i.createTexture({label:s,size:[c,u],format:"r32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST}),f=n.getResolution().slice(0,2),p=1,d=$(a.uniforms.demInfo);d.set({resolution:f,zfactor:p});const x=i.createBuffer({label:s,size:d.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});i.queue.writeBuffer(x,0,d.arrayBuffer);const m=i.createBindGroup({label:s,layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:l},{binding:1,resource:h},{binding:2,resource:{buffer:x}}]}),T=i.createCommandEncoder(),b=T.beginComputePass();b.setPipeline(o),b.setBindGroup(0,m),b.dispatchWorkgroups(g,y,1),b.end();const S=T.finish();return i.queue.submit([S]),l.destroy(),h}}async function fr(r){const e=await fetch(r);if(!e.ok)throw new Error(`Failed to fetch image: ${e.status}`);const t=await e.blob();return await(await or(t)).getImage()}const ur=""+new URL("../data/dem/dem_bh29_2021.tif",import.meta.url).href;async function hr(){const r=await Je();if(r===null){console.error("GPU INFO is NULL");return}const t=Qe({canvasId:"webgpu-canvas",config:{device:r.device,format:r.gpu.getPreferredCanvasFormat()}});if(t===null){console.error("canvasInfo is NULL");return}const n=await fr(ur);cr(r,t,n)}hr();export{yr as L,mr as a};
