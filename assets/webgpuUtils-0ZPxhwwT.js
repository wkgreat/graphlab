import{c as E,a as R,m as _}from"./webgpu-utils.module-DPkR54bZ.js";import{n as B,h as l,s as y,j as S,z as g,k as U,g as f,m as w,r as O,A,e as D,c as F}from"./camera-DXA52umf.js";function z(n){const t=n.device;let r=n.color1,e=n.color2;const s=Math.max(n.density-n.density%2,2);r.every(i=>i<=1)&&(r=r.map(i=>i*255),r[3]=255),e.every(i=>i<=1)&&(e=e.map(i=>i*255),e[3]=255);const o=s,a=s,u=[];for(let i=0;i<o;++i)for(let h=0;h<a;++h)(i+h)%2===0?u.push(...r):u.push(...e);const x=new Uint8Array(u),c=t.createTexture({format:"rgba8unorm",size:[o,a,1],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST});t.queue.writeTexture({texture:c,mipLevel:0,origin:{x:0,y:0,z:0}},x,{offset:0,bytesPerRow:o*4},{width:o,height:a,depthOrArrayLayers:1});const d=t.createSampler({minFilter:"nearest",magFilter:"nearest",addressModeU:"repeat",addressModeV:"repeat"});return{texture:c,sampler:d}}class k{p0=f(0,0,0);p1=f(1,0,0);p2=f(0,1,0);constructor(t,r,e){this.p0=t,this.p1=r,this.p2=e}}class Y{origin;direct;constructor(t,r){this.origin=t,this.direct=B(l(),r)}crossTriangle(t){const e=y(l(),t.p1,t.p0),s=y(l(),t.p2,t.p0),o=S(l(),this.direct,s),a=g(e,o);if(Math.abs(a)<1e-6)return{cross:!1,point:null,distance:null,uvt:[0,0,0]};const u=1/a,x=y(l(),this.origin,t.p0),c=u*g(x,o);if(c<0)return{cross:!1,point:null,distance:null,uvt:[0,0,0]};const d=S(l(),x,e),i=u*g(this.direct,d);if(i<0||c+i>1)return{cross:!1,point:null,distance:null,uvt:[0,0,0]};const h=u*g(s,d),m=U(l(),t.p0,c),v=U(l(),t.p1,i),M=U(l(),t.p2,h),p=f(0,0,0);w(p,p,m),w(p,p,v),w(p,p,M);const P=y(l(),p,this.origin),I=O(P);return{cross:!0,point:p,distance:I,uvt:[c,i,h]}}distanceOfPoint(t){const r=this.origin;this.direct;const e=t,s=y(l(),e,r),o=O(s),a=g(B(l(),this.direct),B(l(),s));if(a<=0)return o;{const u=Math.sin(Math.acos(a));return o*u}}dwithinPoint(t,r){return this.distanceOfPoint(t)<=r}}class Z{positions=[-1,-1,0,1,-1,0,1,1,0,-1,1,0];normals=[0,0,1,0,0,1,0,0,1,0,0,1];texcoords=[0,0,1,0,1,1,0,1];indices=[0,1,2,0,2,3];definition=null;sceneUniform=null;vertexBuffer=null;indexBuffer=null;module=null;pipeline=null;texture=null;sampler=null;constructor(t=100,r=100){const e=t/2,s=r/2;for(let o=0;o<this.positions.length;++o)o%3===0?this.positions[o]*=e:o%3===1&&(this.positions[o]*=s)}refreshVertexBuffer(t){const r=E(t,{position:{data:new Float32Array(this.positions),numComponents:3},texcoord:{data:new Float32Array(this.texcoords),numComponents:2},normal:{data:new Float32Array(this.normals),numComponents:3}}),e=new Uint32Array(this.indices),s=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(s,0,e),this.vertexBuffer=r,this.indexBuffer=s}refreshTexture(t){if(!this.texture||!this.sampler){const r=z({device:t,color1:[.7,.7,.7,1],color2:[.3,.3,.3,1],density:15});this.texture&&this.texture.destroy(),this.texture=r.texture,this.sampler=r.sampler}}refreshUniforms(t,r,e){if(!this.definition){console.error("definition is null");return}const s=R(this.definition.uniforms.scene);s.set({viewmtx:r.viewMtx,projmtx:e.perspectiveMatrixZO}),this.sceneUniform||(this.sceneUniform=t.createBuffer({size:s.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),t.queue.writeBuffer(this.sceneUniform,0,s.arrayBuffer)}initWebGPU(t,r){const e=t.device;this.refreshVertexBuffer(e);const s=`

        struct SceneUniform {
            viewmtx: mat4x4f,
            projmtx: mat4x4f
        }

        @group(0) @binding(0) var<uniform> scene: SceneUniform;

        @group(1) @binding(0) var theTexture: texture_2d<f32>;
        @group(1) @binding(1) var theSampler: sampler;
        
        struct VSInput {
            @location(0) position: vec3f,
            @location(1) texcoord: vec2f,
            @location(2) normal: vec3f
        }

        struct VSOutput {
            @builtin(position) position: vec4f,
            @location(0) texcoord: vec2f,
            @location(1) normal: vec3f
        }

        @vertex fn vs(input: VSInput) -> VSOutput {

            let worldpos = vec4f(input.position, 1.0);
            let ndcpos = scene.projmtx * scene.viewmtx * worldpos;
            var output: VSOutput;
            output.position = ndcpos;
            output.texcoord = input.texcoord;
            output.normal = input.normal;

            return output;

        }
        @fragment fn fs(input: VSOutput) -> @location(0) vec4f {

            var color = textureSample(theTexture, theSampler, input.texcoord);

            return color;
        }
        `;this.definition=_(s),this.module=e.createShaderModule({label:"Ground",code:s}),this.pipeline=e.createRenderPipeline({label:"Ground",layout:"auto",vertex:{module:this.module,buffers:this.vertexBuffer.bufferLayouts},fragment:{module:this.module,targets:[{format:r.context.getConfiguration().format}]},primitive:{topology:"triangle-list"},depthStencil:{format:"depth32float",depthWriteEnabled:!0,depthCompare:"less-equal"}})}draw(t,r,e,s){const o=t.device;this.refreshTexture(o),this.refreshUniforms(o,r,e);const a=o.createBindGroup({label:"Ground",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.sceneUniform}}]}),u=o.createBindGroup({label:"Ground",layout:this.pipeline.getBindGroupLayout(1),entries:[{binding:0,resource:this.texture},{binding:1,resource:this.sampler}]});s.setPipeline(this.pipeline),s.setBindGroup(0,a),s.setBindGroup(1,u),s.setVertexBuffer(0,this.vertexBuffer.buffers[0]),s.setIndexBuffer(this.indexBuffer,"uint32"),s.drawIndexed(6)}}class L{positions=new Float32Array([-1,-1,1,1,-1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,1,1,-1,1,-1]);normals=new Float32Array([...Array(6).fill([0,0,1]).flat(),...Array(6).fill([0,0,-1]).flat(),...Array(6).fill([0,1,0]).flat(),...Array(6).fill([0,-1,0]).flat(),...Array(6).fill([1,0,0]).flat(),...Array(6).fill([-1,0,0]).flat()]);texcoords=new Float32Array([...Array(6).fill([0,1,1,1,1,0,0,1,1,0,0,0]).flat()]);colors=null;vertexCount=36;inputColors;colorMode;constructor(t){t.colors&&t.colors.length!==0?this.inputColors=t.colors:this.inputColors=[[1,1,1,1]],this.colorMode=t.colormode||"face",this.genCubeColors()}genCubeColors(){let t=0;this.colorMode==="vertex"?t=1:this.colorMode==="triangle"?t=3:this.colorMode==="face"&&(t=6);const r=[],e=this.inputColors.length;for(let s=0;s<this.vertexCount;++s){const o=Math.floor(s/t)%e,a=this.inputColors[o];r.push(a)}this.colors=new Float32Array(r.flat())}}class X extends L{positions=new Float32Array([-1,-1,1,1,-1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,0,-1,1,0,1,1,0,-1,-1,0,1,1,0,1,-1,0,-1,1,0,-1,1,1,1,1,1,-1,1,0,1,1,1,1,1,0,-1,-1,0,1,-1,0,1,-1,1,-1,-1,0,1,-1,1,-1,-1,1,1,-1,0,1,1,0,1,1,1,1,-1,0,1,1,1,1,-1,1,-1,-1,0,-1,-1,1,-1,1,1,-1,-1,0,-1,1,1,-1,1,0]);normals=new Float32Array([...Array(6).fill([0,0,1]).flat(),...Array(6).fill([0,0,-1]).flat(),...Array(6).fill([0,1,0]).flat(),...Array(6).fill([0,-1,0]).flat(),...Array(6).fill([1,0,0]).flat(),...Array(6).fill([-1,0,0]).flat()]);texcoords=new Float32Array([...Array(6).fill([0,1,1,1,1,0,0,1,1,0,0,0]).flat()]);constructor(t){super(t)}}function T(n,t,r,e){return[n[0]+t,n[1]+r,n[2]+e]}function b(n,t,r){const e=n*Math.sin(r)*Math.cos(t),s=n*Math.sin(r)*Math.sin(t),o=n*Math.cos(r);return[e,s,o]}function H(n=1,t=10,r=10,e=[0,0,0]){const s=[],o=[],a=[],u=2*Math.PI/t,x=Math.PI/r;for(let c=0;c<t;++c)for(let d=0;d<r;++d){const i=-Math.PI+c*u,h=-Math.PI+(c+1)*u,m=-Math.PI/2+d*x,v=-Math.PI/2+(d+1)*x,M=T(b(n,i,Math.PI/2-m),e[0],e[1],e[2]),p=T(b(n,h,Math.PI/2-m),e[0],e[1],e[2]),P=T(b(n,h,Math.PI/2-v),e[0],e[1],e[2]),I=T(b(n,i,Math.PI/2-v),e[0],e[1],e[2]),C=A(l(),f(...M),f(...e)),V=A(l(),f(...p),f(...e)),G=A(l(),f(...P),f(...e)),N=A(l(),f(...I),f(...e));s.push(...M),o.push(...C),a.push((i+Math.PI)/(2*Math.PI),(m+Math.PI/2)/Math.PI),s.push(...P),o.push(...G),a.push((h+Math.PI)/(2*Math.PI),(v+Math.PI/2)/Math.PI),s.push(...I),o.push(...N),a.push((i+Math.PI)/(2*Math.PI),(v+Math.PI/2)/Math.PI),s.push(...M),o.push(...C),a.push((i+Math.PI)/(2*Math.PI),(m+Math.PI/2)/Math.PI),s.push(...p),o.push(...V),a.push((h+Math.PI)/(2*Math.PI),(m+Math.PI/2)/Math.PI),s.push(...P),o.push(...G),a.push((h+Math.PI)/(2*Math.PI),(v+Math.PI/2)/Math.PI)}return{hasIndices:!1,nvertices:s.length/3,verticeSize:3,vertices:new Float32Array(s),normals:new Float32Array(o),texcoords:new Float32Array(a)}}class W{#e=Math.PI/3;#t=1;#r=.1;#s=1e10;constructor(t,r,e,s){this.#e=t,this.#t=r,this.#r=e,this.#s=s}get perspectiveMatrix(){return D(F(),this.#e,this.#t,this.#r,this.#s)}get perspectiveMatrixZO(){return D(F(),this.#e,this.#t,this.#r,this.#s)}get fovy(){return this.#e}get fovx(){const t=this.#e/2,r=Math.tan(t);return 2*Math.atan(r*this.aspect)}get near(){return this.#r}get far(){return this.#s}set aspect(t){this.#t!==t&&(this.#t=t)}get aspect(){return this.#t}}function $(n){let t="clear";return n.first?t="clear":t="load",{label:n.label,colorAttachments:[{clearValue:n.clearColor,loadOp:t,storeOp:"store",view:n.colorTexture}],depthStencilAttachment:{view:n.depthTexture,depthClearValue:n.clearDepth,depthLoadOp:t,depthStoreOp:"store"}}}function J(n,t,r,e="depth32float"){return n.device.createTexture({label:"depthTexture",size:[t,r],format:e,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST})}export{Z as G,X as N,W as P,Y as R,k as T,$ as a,H as b,J as c};
